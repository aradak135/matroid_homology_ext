use application 'matroid';
use Data::Dump qw(dump);

# Obtains size of the ground set, rank, and the class of matroids to be conisdered.
sub getUserInfo {
	print "This script will compute the dimension of one of the (r,n)-homology groups. \n";
	print "How many elements in the matroids: ";
	my $n = <>;
	chomp($n);
	print "What is the rank of the matroids: ";
	my $r = <>;
	chomp($r);
	
	my $oper = 0;
	while($oper != 1 and $oper != 2){
		print "Contraction (1) or deletion (2)? ";
		$oper = <>;
		chomp($oper);
	}
	
	print "What minor-closed class of matroids are to be considered? \n";
	print "Use all caps and enter a polyDB recognized descriptor. \n";
	print "If you wish to consider all matroids, enter NESTED. \n";
	printn "Desired class: ";
	my $MATROIDCLASS = <>;
	chomp($MATROIDCLASS);
	}
	return ($n,$r,$oper,$MATROIDCLASS);
}

#Open polyDB and create proper cursor
#Currently uses ifelifelse structure rather than passing a string. Should be changed when added to extension.
sub collectionFromPolyDB {
	my $n = $_[0];
	my $r = $_[1];
	my $MATROIDCLASS = $_[2];
	polyDB;
	$PolyDB::default::db_section_name = "Matroids";
	$PolyDB::default::db_collection_name = "Small";
	my $collection = polyDB->get_collection();
	#For the dual case ask that it have no coloops
	my $matroidsRN;
	my $matroidsCount;
	
	if($n/2>=$r){
		$matroidsRN = $collection->find({N_ELEMENTS => int($n), RANK => int($r), N_LOOPS => 0,$MATROIDCLASS=>true});
		$matroidsCount = $collection->count({N_ELEMENTS => int($n), RANK => int($r), N_LOOPS => 0,$MATROIDCLASS=>true});
	}
	else{
		$matroidsRN = $collection->find({N_ELEMENTS => int($n), RANK => int($n-$r), "DUAL.N_LOOPS" => 0,$MATROIDCLASS=>true});
		$matroidsCount = $collection->count({N_ELEMENTS => int($n), RANK => int($n-$r), "DUAL.N_LOOPS" => 0,$MATROIDCLASS=>true});
	}
	
	return ($matroidsRN,$matroidsCount);
}

sub main {
	my ($n,$r,$oper,$MATROIDCLASS) = getUserInfo();
	my $nMinusOne = $n-1;
	my $rMinusOne = $r-1;
	my $dualCheck = 0;
		
	#Obtains cursor from polyDB
	my ($matroidsRN,$matroidsCount) = collectionFromPolyDB($n,$r,$MATROIDCLASS);
	
	if($r>$n/2){
		$dualCheck =1;
	}
	
	# Obtains chainIndices from correct file. All chains produced by chain_generator_python.py
	# Maps are considered d:(M_{r,n}->M_{r,n-1}) or c:(M_{r,n}->M_{r,n-1}
	my $domainChainFile = "chainIndices_n${n}_r${r}.txt";
	open (FH,'<',$domainChainFile);
	my $domainChains = eval(<FH>);
	close(FH);
	# $oper = 1 is contraction and 2 is deletion.
	my $rangeChainFile;
	if($oper == 1){
		$rangeChainFile = "chainIndices_n${nMinusOne}_r${rMinusOne}.txt";
	}
	elsif($oper == 2){
		$rangeChainFile = "chainIndices_n${nMinusOne}_r${r}.txt";
	}
	open (FH,'<',$rangeChainFile);
	my $rangeChains = eval(<FH>);
	close(FH);
	
	my $lengthOfDomainVector = scalar(@$domainChains);
	my $lengthOfRangeVector = scalar(@$rangeChains);
	
	#We initialize the matrix of domain and range indictor vectors, including some redundancies due to relabeling.
	my $facN = new Int(fac($n));
	my $group = group::symmetric_group($n);
	my $listOfMatrixRepOfSn = representationOfSn($n,$r,$domainChains,$lengthOfDomainVector);
	my $matrixOfDomainIndicatorVectors = new Matrix($matroidsCount*$facN,$lengthOfDomainVector);
	my $matrixOfRangeIndicatorVectors = new Matrix($matroidsCount*$facN,$lengthOfRangeVector);
	my $indVecRowCount = 0;
	
	while($matroidsRN->PolyDB::Cursor::has_next){
		my $matroid = $matroidsRN->PolyDB::Cursor::next;
		if($dualCheck){
			$matroid = dual($matroid);
		}
		
		#The following computations relate only to the domain and are not affected by the operations, so we can later use permutation matrices to obtain all other indicator vectors just by having one in the isomorphism class
		my $listOfChainMatrices = chainsOfFlats($matroid,$n,$r);
		my $domainIndicatorVector = indicatorVectorProducer($matroid,$n,$r,$domainChains,$lengthOfDomainVector,$listOfChainMatrices);
		my $permCounter = 0;
		
		#Unfortunantly, the kernel is not generated by single matroid indicator vectors, but by some linear combinations of them (i.e. m1+m2 may be in the kernel but not m1 or m2). Because of this, we need to store the actual image rather than just check if it's zero. Moreover, relabelings change the signs of the sum on the minors. It is possible that there exists a matroid whose image is unrelated to the image of a relabeled matroid by permutations. This requires expensive computations at this time. If the action of S_n on deletion is known, this can be resolved. I.e. if one can guess \sigma \partial_d(m) when given \partial_d( \sigma m).
		for my $perm (@{group::all_group_elements($group->PERMUTATION_ACTION)}){
			my $permBases = [];
			for my $base (@{$matroid->BASES}){
				push @{$permBases}, group::action($perm,$base);
			}
			my $permMatroid = new Matroid(N_ELEMENTS => int($n),BASES=>$permBases);
			#Here we can use the nice properties of the domain to avoid calling indicatorVectorProducer.
			$matrixOfDomainIndicatorVectors->row($indVecRowCount) = $domainIndicatorVector*$listOfMatrixRepOfSn->[$permCounter];
			
			my $rangeIndicatorVector;
			if($oper == 1){
				$rangeIndicatorVector = imageContractionDeletion($permMatroid,$n,$r,$rangeChains,$lengthOfRangeVector);
			}
			elsif($oper == 2){
				$rangeIndicatorVector = imageKernelDeletion($permMatroid,$n,$r,$rangeChains,$lengthOfRangeVector);
			}
			$matrixOfRangeIndicatorVectors->row($indVecRowCount) = $rangeIndicatorVector;
			
			$permCounter = $permCounter+1;
			$indVecRowCount = $indVecRowCount+1;
		}
		
	}
	#I have it print out an extra row so that we can be sure the printed matrix contins all entries. If the final row is non-zero, something has gone wrong.
	
	#print $matrixOfDomainIndicatorVectors;#->minor([0..$indVecRowCount],All);
	#print "\n";
	#print $matrixOfRangeIndicatorVectors;
	
	print "Dim of domain M_{r,n}: ";
	print rank($matrixOfDomainIndicatorVectors);
	print "\n";
	print "Dim of image M_{r,n}->: ";
	print rank($matrixOfRangeIndicatorVectors);
	print "\n";
	
	print "Dim of kernel: M_{r,n}->:";
	print rank($matrixOfDomainIndicatorVectors)-rank($matrixOfRangeIndicatorVectors);
	print "\n";
	exit;
}

main()